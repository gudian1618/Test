

代码块：
    1、普通代码块，在方法中写的代码块
    2、构造块，是类中定义的代码块，在创造对象时被调用，优于构造方法执行
    3、静态代码块，使用static声明的代码块，第一次使用的时候被调用（创建对象时），只执行一次，优于代码块，用于初始化只调用一次的数据，如读配置文件和信息
    4、同步代码块（多线程、同步）

    小结：
    使用顺序：重点使用静态代码块、普通代码块、同步代码块（多线程使用）、构造代码块（基本不用）

单例设计模式：保证一个类仅有一个实例，并提供一个全局访问点
    1、构造方法私有化
    2、声明一个本类对象
    3、给外部提供一个静态方法获取对象

    实现方式：
    1、懒汉式（被动，占用内存时间短，效率低，延迟加载）：第一次调用getInstance方法时，对象被创建，程序结束时释放
    2、饿汉式（主动，占用内存时间长，提高效率）：类被加载时，对象被创建，程序结束时释放

    在项目中使用单例，有什么好处？
    1、在设计工具类的时候，只有方法没有属性，只有属性才与对象有关
    2、工具类可能会被频繁调用
    3、目的是节省重复创建对象所带来的内存消耗，从而提高效率。

    能不能用构造方法私有化+静态方法来替代单力设计模式？
    有
    在JDK中的math类（速度快）

    单例省内存，速度慢一点；静态方法+构造方法私有化，速度快一点，吃内存

继承：从已有的类创建新类的过程（类图）
    1、被继承的为父类（超类），继承父类的类成为子类（派生类）
    2、可以一个对象直接使用另一个对象的属性和方法
    3、继承可以实现代码重用
    继承一个父类，只能继承非私有的数据（属性和方法）
    也就是说，private不能被继承，但可以通过get、set注入操作
    protected访问权限修饰符，就是用来被继承使用的，父类中使用protected的方法属性就是用来或者可以被子类继承使用

    1、java只能实现单继承，一个类只能有一个父类
    2、允许多层继承，一个子类有一个父类，一个父类可以有其他父类
    3、构造方法不能被继承
    4、创建对象会调用构造方法、但是调用构造方法不一定就是创建对象
    5、实例化子类，会先调用父类的构造方法，如果父类中没有默认的构造方法，子类必须显式的通过super(...)调用父类的带参构造方法
    6、super只能在子类构造方法中的第一句

    创建子类对象时，父类的构造方法也会被调用，因为子类要使用到父类的数据，那么就要通过父类的构造方法来初始化数据，如果创建子类对象时使用默认的构造方法，那么父类的默认构造方法也会被调用。

    继承的好处
    1、提高代码的复用性
    2、维护性
    3、使类与类之间产生关系，是多态的前提
    缺点：增强了类之间的耦合性
    原则：高内聚、低耦合

    方法的重写
    子类继承父类的方法，想要修改，就是重写。方法重写又称为覆盖。
    方法重写也就是覆盖的两个方法返回值、方法名、参数列表必须完全一致
    覆盖，体现在子类调用父类方法，但是不能完全满足需求，需要修改方法，也就是程序扩展。

    1、方法重写的两个方法返回值、方法名、参数列表必须完全一致（子类重写父类的方法）
    2、子类抛出的异常不能超过父类相应方法的异常（子类异常不能大于父类）
    3、子类方法的访问级别不能低于父类（子类大于等于父类）
    4、父类中方法使用private、static、final的时候，不能被子类重写

    overloading与overriding的区别？
    overloading:方法重载，发生在同一个类中，方法名相同，参数列表不同，与返回值无关
    overridng:方法重写，发生在子父类中，方法名、返回值、参数列表要相同（三同），但是方法内容不同

    super关键字
    1、用来调用父类的属性，从父类中获得信息,super.属性，如果是继承过来的属性，super可省略
    2、调用父类的方法，
    3、调用父类的构造方法（super(实参)），必须在子类构造方法的第一句，调用父类相应的构造方法，若不显式的写出来，默认调用父类的无参构造方法，如：super();
    this表示当前对象
    使用super来调用父类的属性、方法和构造方法











